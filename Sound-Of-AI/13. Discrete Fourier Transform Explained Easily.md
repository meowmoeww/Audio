### 이전 시간

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/76a1864b-0ded-4780-af98-29df3ebcb0bc)

g(t)에 대해서 푸리에 변환에 대해서 배웠다.

저번 시간에 사용한 g(t)는 원본 신호로 아날로그 신호이지만, 이번 시간에는 디지털 신호를 사용하여 푸리에 변환을 진행해보려고 한다.

### Digitalization

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/b1587647-1066-4456-8de4-d416eb269384)

저번에 배운 샘플링 기법을 다시 떠올려보자면, 가로축은 시간 세로축은 진폭이 존재할 때, 추출하고자 하는 샘플의 갯수에 따라 sampling_rate가 결정되고, 원본 신호에서 추출하고자 하는 각 점들을 sample points라고 한다. 이전 샘플 포인트와 다음 샘플 포인트 사이의 거리를 지속시간이라고 한다. 

### Digital signal

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/6ed99e00-6665-4191-87ad-596939d9e1c1)

원본 신호의 g(t)는 디지털 신호의 x(n)이 된다.

이때 원본 신호에서 t의 지점은 디지털 신호에서 n번째 샘플포인트 * 샘플간의 지속기간을 곱한 지점과 동일하다. 

### Building a discrete Fourier tarnsform

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/ddc94646-23a3-48a1-a69c-92cdda360502)

기존의 푸리에 변환은 , 원본 신호에 주파수의 사인파를 곱하여, 푸리에 변환계수를 만들어준다면,

디지털 신호에서의 푸리에 변환은, 원본신호에 사인파의 값을 곱하여 이를 더해주어 푸리에 변환계수를 만들어준다. 

### DFT : Visual interpretation

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/8f1de6be-7f40-4e03-a244-bafd5ade4bbd)

위의 식을 계산할 때 두가지 문제점이 있다, 주파수는 연속적이라는 것과 시간은 무한하다는 다른 개념 때문에 발생하는 것인데

첫 번째는 이산 시간 신호를 이산 주파수로 변환하는 과정이므로, 연속적인 주파수의 값 대신 이산 주파수 값을 고려해야 합니다. 

두 번째는 DFT는 유한한 길이의 시간 도메인 신호를 처리하는데 사용되므로, 시간은 무한대가 아니라 유한한 구간에 대해서만 고려됩니다. 따라서 입력 신호의 길이가 결정되면 해당 길이 내에서만 주파수 성분이 추출됩니다. 길이가 길수록 주파수 해상도는 좋아지지만, 계산량은 늘어납니다.

### Building a discrete Fourier transform

따라서 우리는 아래의 정의를 통해서 디지털 신호를 사용해 푸리에 변환을 하려고 한다. 

### Time

- Consider f to be non 0 in a finite time interval
● x(0), x(1), …, x(N-1)

원래 신호를 분해하려는 주파수는 유한한 시간 간격에서만 0이 아닌 것으로 간주한다, 이는 신호가 일정한 길이 동안 존재하고 그 후에는 없어진다고 가정하는 것이다.

또한 디지털 신호는 샘플링을 통해 복원된 신호이므로, 유한한 샘플에만 집중이 가능하다.

### Frequency

- Compute transform for finite # of frequencies
- # frequencies (M) = # samples (N)

우리가 고려하는 주파수의 수는 이산 푸리에 변환을 취하고 싶은 신호에 있는 샘플 수 n과 같다. 

- 왜 M=N 이어야 하나?

시간 영역에서 주파수 영역과, 주파수 영역에서 시간영역 사이에 아주 쉽게 이동할 수 있기 때문이다.

또한 계산과정에서 효율적이기 때문이다. 

### Hacking our way around

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/fd3178ab-d8d5-4b09-a907-949062f08c3e)

따라서 원래의 문제는 무한한 샘플의 수는 합산하는 것이었는데 약간의 변화를 주어 

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/e2c3d957-9db8-4fbf-b390-4adee98676c9)

N개의 샘플만 고려하도록 제한한다. 
여기서 주목해야할 점은 푸리에 변환 계산을 위해 고려해야 하는 주파수의 값이 k/N으로 표시된다는 점이다. 

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/694c9a83-ab66-45d8-b9b1-23267c696f5a)

k = [0,M-1] = [0,N-1]

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/fc1e6bcd-aaee-452f-83aa-ef0a231c332d)

주어진 값 k의 푸리에 변환의 출력으로 얻은 주파수는 , k/n에 샘플링 레이트의 역수인 T의 역수를 곱해준 값이다.

![image](https://github.com/meowmoeww/Sound-Of-AI/assets/89447043/5293081a-c462-48ce-8974-ee7a400bda1f)

이는 다시 1/T = sr이므로 분자에 sr를 곱해준다. 

따라서 푸리에 변환의 출력으로 얻은 주파수의 범위는 k가 0일 때와, sampling_rate 사이에 있다는 것을 알 수 있다. ( 0과 샘플링 속도 사이의 이 범위와 같은 수의 분할을 취한다.)

