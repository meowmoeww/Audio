### 이전 시간

![image](https://github.com/meowmoeww/Audio/assets/89447043/845577c1-a888-4a78-b0f5-7a1edc110436)

연속적인 신호인 g(t)에 대해서 푸리에 변환을 하는 법 대해서 배웠다.

저번 시간에 사용한 g(t)는 원본 신호로 아날로그 신호이지만, 이번 시간에는 디지털 신호를 사용하여 푸리에 변환을 진행해보려고 한다. 

### Digitalization

![image](https://github.com/meowmoeww/Audio/assets/89447043/1c18575a-a7cb-481e-8e5c-d49d9a6569d0)

저번에 배운 샘플링 기법을 다시 떠올려보자면, 가로축은 시간 세로축은 진폭이 존재할 때, 추출하고자 하는 샘플의 갯수에 따라 sampling_rate가 결정되고, 원본 신호에서 추출하고자 하는 각 점들을 sample points라고 한다. 이전 샘플 포인트와 다음 샘플 포인트 사이의 거리를 지속시간이라고 한다. 

### Digital signal

![image](https://github.com/meowmoeww/Audio/assets/89447043/23f0fe2a-703b-4d36-aaa5-dbc1d9036587)

원본 신호의 g(t)는 디지털 신호의 x(n)이 된다.

이때 원본 신호에서 t의 지점은 디지털 신호에서 n번째 샘플포인트 * 샘플간의 지속기간을 곱한 지점과 동일하다. 

### Building a discrete Fourier transform

![image](https://github.com/meowmoeww/Audio/assets/89447043/1220b426-246f-46c6-b0ef-28cc2b83acb8)

기존의 푸리에 변환은 , 원본 신호에 주파수의 e ^−2πft를 곱한 값을 적분하여 푸리에 변환계수를 만들어준다면, 디지털 신호에서의 푸리에 변환은, 원본신호에  e ^−2πft를 곱한 값을 더해주어 푸리에 변환계수를 만들어준다. 

### DFT : Visual interpretation

![image](https://github.com/meowmoeww/Audio/assets/89447043/2c7697e4-55ee-4f55-847e-4e93b0092c72)

위의 식을 계산할 때 두가지 문제점이 있다, 주파수는 연속적이라는 것과 시간은 무한하다는 것이다. 

첫 번째는 이산 시간 신호를 이산 주파수로 변환하는 과정이므로, 연속적인 주파수의 값 대신 이산 주파수 값을 고려해야 한다. 

두 번째는 DFT는 유한한 길이의 (시간 도메인) 신호를 처리하는데 사용되므로, 시간은 무한대가 아니라 유한한 구간에 대해서만 고려된다. 따라서 입력 신호의 길이가 결정되면 해당 길이 내에서만 주파수 성분이 추출된다. 길이가 길수록 주파수 해상도는 좋아지지만, 계산량은 늘어난다.

### Building a discrete Fourier transform

따라서 우리는 아래의 정의를 통해서 디지털 신호에 대해 푸리에 변환을 하려고 한다. 

![image](https://github.com/meowmoeww/Audio/assets/89447043/f1a7ec27-eb78-413e-bc91-c4a28a8096ef)

### Time

주파수가 유한한 시간 간격에서 0이 아닌 값을 가진다고 간주한다, 이는 신호가 유한한 시간 동안에만 존재한다는 것을 의미한다. 실제로 DFT를 계산할 때 신호 x의 샘플을 x(0), x(1),…,x(N-1)과 같이 유한한 개수로 가정하고 계산하기 때문에 연속 신호를 유한한 샘플로 근사해 분석할 수 있다. 

### Frequency

- DFT는 유한한 수의 주파수에 대해 계산된다. 신호를 분석할 때 모든 가능한 주파수를 고려하는 것이 아니라, 샘플의 수에 해당하는 유한한 수의 주파수 포인트에서만 변환을 수행한다.
- 주파수의 수(M) = 샘플의 수(N)

우리가 고려하는 주파수의 수는 이산 푸리에 변환을 취하고 싶은 신호에 있는 샘플 수 n과 같다. 

- 왜 M=N 이어야 하나?

시간 영역에서 주파수 영역과, 주파수 영역에서 시간영역 사이에 아주 쉽게 이동할 수 있으며 계산과정에서 효율적이다. 

### Hacking our way around

![image](https://github.com/meowmoeww/Audio/assets/89447043/5201bc4a-9a9e-476d-926e-1f93bfbff323)

따라서 원래의 문제는 무한한 샘플의 수는 합산하는 것이었는데 약간의 변화를 주어 

![image](https://github.com/meowmoeww/Audio/assets/89447043/c2d23c3e-5898-4806-8318-12ecb2a0a692)

N개의 샘플만 고려하도록 제한한다. 

![image](https://github.com/meowmoeww/Audio/assets/89447043/dacceca2-f5a5-4da2-a4d2-2a4e2f2db3f8)

여기서 주목해야할 점은 푸리에 변환 계산을 위해 고려해야 하는 주파수의 값이 k/N으로 표시된다는 점이다.  ( k = [0,M-1] = [0,N-1] )

k/N은 정규화된 주파수 인덱스로 이를 통해 다양한 길이의 신호들 간에 주파수 성분을 비교할 수 있다. 

![image](https://github.com/meowmoeww/Audio/assets/89447043/e3f2beda-3d94-4c3e-b080-9474799bf3e1)

주어진 값 k의 주파수는( F(k) ) 헤르츠로 주어지며 위의 식과 같이 k/NT의 값이다. 

( T = 1/sr 인 샘플링 기간 ) 이기 때문에 분자에 sr을 곱해준다.

이는 푸리에 변환으로 얻은 주파수의 범위는 k가 0 일 때인 0부터 sampling rate까지이다. 

따라서 샘플링 레이트는 푸리에 변환을 적용할 때 고려하는 주파수 범위와도 같은 것이다.

 

## Redundancy in DFT

![image](https://github.com/meowmoeww/Audio/assets/89447043/8eacefc1-3562-45f3-836d-7856780ce731)

디지털 푸리에 변환으로부터 나온 계수에 대한 크기를 시각화하 한 것이다. 

sr은 22050정도가 되는데 가운데를 기준으로 대칭인 것을 볼 수 있다. 

![image](https://github.com/meowmoeww/Audio/assets/89447043/2936e7b0-e730-462d-853c-e96b56e785c1)

N을 2로 나눈 k를 볼 때 이는 sr을 2로 나눈 값이며 우리는 이 선을 기준으로 왼쪽만 고려해도 된다는 것이다. 

Nyquist Frequency 이산 신호를 표현할 수 있는 최대 주파수이며 이  이상의 주파수에서는 신호를 올바르게 복원할 수 없어, 앨리어싱(Aliasing)이라는 현상이 발생할 수 있다. 

### From DFT to Fast Fourier Transform

- DFT는 계산량이 많은 작업이다. *N*2의 복잡도를 가지므로, 샘플의 수가 많을 때 매우 비효율적이다
- FFT는 더 효율적인 계산 방식으로, *N*log2*N*의 복잡도를 가진다. 이는 특히 큰 데이터 셋에 대해 DFT보다 훨씬 빠르게 계산된다
- FFT는 사인파(sinusoids)들 사이의 중복성을 이용합니다. 같은 연산을 여러 번 반복하지 않도록 특정 패턴을 찾아 계산을 줄인다.
- FFT는 *N*이 2의 거듭제곱일 때 작동한다. 이는 FFT가 효율적으로 작동하도록 하기 위한 조건 중 하나이다
